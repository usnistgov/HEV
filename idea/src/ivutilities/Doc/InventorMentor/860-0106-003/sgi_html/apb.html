<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>Appendix B. An Introduction to the C API</title><meta name="generator" content="DocBook XSL Stylesheets V1.49"><meta name="generator" content="SGI XSL DocBook Customization Stylesheets V1.0"><link rel="home" href="index.html" title="The Inventor Mentor:

Programming Object-Oriented 
3D Graphics with Open Inventor&#8482;,
Release 2"><link rel="up" href="index.html" title="The Inventor Mentor:

Programming Object-Oriented 
3D Graphics with Open Inventor&#8482;,
Release 2"><link rel="previous" href="apa.html" title="Appendix A. An Introduction to Object-Oriented Programming for C Programmers"><link rel="next" href="apc.html" title="Appendix C. Error Handling"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Appendix B. An Introduction to the C API</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="apa.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="apc.html">Next</a></td></tr></table><hr></div><!--CONTENT_BEGIN--><div class="appendix"><div class="titlepage"><div><h2 class="title"><a name="id5517905"></a>Appendix B. <a name="id23008"></a>An Introduction to the C API</h2></div></div>
<p>Read this chapter if you will be programming in C! If you are unfamiliar with object-oriented programming, you should first read <a href="apa.html#id41783">Appendix A</a>, which introduces some of the features of C++ and some of the conceptual underpinnings of the Open Inventor C interface.</p>
<p>Though the C++ syntax is different, the concepts described in earlier chapters of this book still apply to the C implementation of Open Inventor. As you read the rest of this book, you can refer to this appendix as necessary to translate the C++ examples into C. If you have purchased Open Inventor, you can also compare the C version of each online example program to the C++ version in this book. See the release notes for information on finding and using the online example programs and for details on how to compile and link an Inventor program written in C.</p>
<p>The following sections explain the differences between the Open Inventor C and C++ interfaces. They discuss these topics:</p>
<div class="itemizedlist"><ul type="disc"><li><p><a href="apb.html#id67419">&#8220;Naming C Functions&#8221;</a></p>
</li>
<li><p><a href="apb.html#id38198">&#8220;Abbreviating C Function Names&#8221;</a></p>
</li>
<li><p><a href="apb.html#id89901">&#8220;Creating and Deleting Objects from C&#8221;</a></p>
</li>
<li><p><a href="apb.html#id15842">&#8220;Calling Functions&#8221;</a></p>
</li>
<li><p><a href="apb.html#id55306">&#8220;C Classes and Manual Pages&#8221;</a></p>
</li>
<li><p><a href="apb.html#id26364">&#8220;A Sample Open Inventor Program in C&#8221;</a></p>
</li>
</ul></div><p>The Open Inventor C interface is generated by an automated translation program. This interface defines a C structure for each C++ class, which is actually a direct mapping to the C++ class. This structure is defined in the C include file for the class. Fields within the C structure are either hidden or public. Public fields (member variables) are documented in the reference manual page for each class. Hidden fields (private member variables) are named <span class="bold"><b>pad[]</b></span>. You should not modify hidden fields.<a name="idappb1"></a></p>
<p>The sample code fragments in these sections are drawn from <a href="ch02.html#id36498">Chapter 2</a>. </p>
<div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5518165"></a><a name="id67419"></a>Naming C Functions</h2></div></div>
<p>The name of each C function is the C++ member function prefixed by the class name. Suppose there were a class named <a name="idappb2"></a><a name="idappb3"></a><a name="idappb4"></a><span class="bold"><b>SoGenericType</b></span>, with a member function <span class="bold"><b>doOp()</b></span>. The C name for that function would be <span class="bold"><b>SoGenericTypeDoOp()</b></span>. The object to be operated upon by the member function appears as the first argument to the C version of the function. A C prototype for our generic hypothetical function would look something like this:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SoGenericTypeDoOp(SoGenericType *);
</pre></td></tr></table><p>To give a more specific example, the function to add a node to a group looks like this in C++ and C:</p>
<p>C++:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
root-&gt;addChild(material);
C:
SoGroupAddChild(root, (SoNode *) material);
</pre></td></tr></table><p>The C function name has the prefix <span class="bold"><b>SoGroup</b></span>. Since <span class="bold"><b>addChild()</b></span> is a member function of <span class="bold"><b>SoGroup</b></span>, the first argument to the C function must be a pointer to an object of type <span class="bold"><b>SoGroup</b></span>. Since <span class="bold"><b>addChild()</b></span> expects a pointer to an object of type <span class="bold"><b>SoNode</b></span> as its second argument, use a cast to <span class="bold"><b>SoNode *</b></span> if you need to.</p>
<p>Now, suppose that you want to apply the function <a name="idappb5"></a><a name="idappb6"></a><a name="idappb7"></a><span class="bold"><b>doOp()</b></span> to a member of a subclass of <span class="bold"><b>SoGenericType</b></span>, like <span class="bold"><b>SoGenericSubType</b></span>. The C subclasses inherit all the member functions of their parent classes in the form of macro functions. The macros simply call the parent class function and cast the object to the parent's object type. The names of the inherited macro functions, though, are prefixed with the name of the subclass, not the parent class. So the C function name for <span class="bold"><b>doOp() </b></span>would be <span class="bold"><b>SoGenericSubTypeDoOp()</b></span>. You could use the parent class funtion, <span class="bold"><b>SoGenericTypeDoOp()</b></span>, if you cast the object to <span class="bold"><b>SoGenericType</b></span>.</p>
<p>In the real Inventor example <span class="bold"><b>addChild()</b></span>, you're more likely to be adding children to subclasses of <span class="bold"><b>SoGroup</b></span>. For example, the C macro function to add a child node to a separator is</p>
<p>C:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SoSepAddChild(separator, (SoNode *) material);
</pre></td></tr></table><br></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5518480"></a><a name="id38198"></a>Abbreviating C Function Names</h2></div></div>
<p>Here is another example of an Open Inventor C function:<a name="idappb8"></a><a name="idappb9"></a><a name="idappb10"></a></p>
<p>C++:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
viewer = new SoXtExaminerViewer(myWindow);
viewer-&gt;setSceneGraph(root);
C:
viewer = SoXtExamVwrCreateStd(myWindow, NULL);
SoXtExamVwrSetScene(viewer, (SoNode *) root);
</pre></td></tr></table><p>The C++ function <span class="bold"><b>setSceneGraph()</b></span> is a member of the class <span class="bold"><b>SoXtRenderArea</b></span>, but the viewer is a pointer to type <span class="bold"><b>SoXtExamVwr</b></span>. So the C macro function name is prefixed with <span class="bold"><b>SoXtExamVwr</b></span> and has a pointer to an object of that type as its first argument.</p>
<p>But as you can see, the C function name is abbreviated. The function in the preceding example, if it were unabbreviated, would be <span class="bold"><b>SoXtExaminer-ViewerSetScene()</b></span>, which is long and unwieldy. <a href="apb.html#id34324">Table B-1</a> lists the abbreviations used in the C function names. Whenever the C++ function name contains one of the strings listed in the table, the corresponding C function uses the abbreviation in the second column.</p>
<div class="table"><p><a name="id5518586"></a><b>Table B-1. <a name="id34324"></a>C Function Name Abbreviations</b></p>
<table summary="C Function Name Abbreviations" border="1"><colgroup><col><col></colgroup><thead><tr valign="top"><th valign="top"><p>C++ Function Name</p>
</th><th valign="top"><p>Abbreviation</p>
</th></tr></thead><tbody><tr valign="top"><td valign="top"><p>Action</p>
</td><td valign="top"><p>Act</p>
</td></tr><tr valign="top"><td valign="top"><p>Attenuation</p>
</td><td valign="top"><p>Atten</p>
</td></tr><tr valign="top"><td valign="top"><p>Binding</p>
</td><td valign="top"><p>Bind</p>
</td></tr><tr valign="top"><td valign="top"><p>BoundingBox</p>
</td><td valign="top"><p>BBox</p>
</td></tr><tr valign="top"><td valign="top"><p>Button</p>
</td><td valign="top"><p>Btn</p>
</td></tr><tr valign="top"><td valign="top"><p>Callback</p>
</td><td valign="top"><p>CB</p>
</td></tr><tr valign="top"><td valign="top"><p>Camera</p>
</td><td valign="top"><p>Cam</p>
</td></tr><tr valign="top"><td valign="top"><p>Catalog</p>
</td><td valign="top"><p>Cat</p>
</td></tr><tr valign="top"><td valign="top"><p>Character</p>
</td><td valign="top"><p>Char</p>
</td></tr><tr valign="top"><td valign="top"><p>Color</p>
</td><td valign="top"><p>Col</p>
</td></tr><tr valign="top"><td valign="top"><p>Component</p>
</td><td valign="top"><p>Comp</p>
</td></tr><tr valign="top"><td valign="top"><p>Cylinder</p>
</td><td valign="top"><p>Cyl</p>
</td></tr><tr valign="top"><td valign="top"><p>Decoration</p>
</td><td valign="top"><p>Decor</p>
</td></tr><tr valign="top"><td valign="top"><p>Detail</p>
</td><td valign="top"><p>Dtl</p>
</td></tr><tr valign="top"><td valign="top"><p>Direction</p>
</td><td valign="top"><p>Dir</p>
</td></tr><tr valign="top"><td valign="top"><p>Directory</p>
</td><td valign="top"><p>Dir</p>
</td></tr><tr valign="top"><td valign="top"><p>Editor</p>
</td><td valign="top"><p>Ed</p>
</td></tr><tr valign="top"><td valign="top"><p>Environment</p>
</td><td valign="top"><p>Env</p>
</td></tr><tr valign="top"><td valign="top"><p>Event</p>
</td><td valign="top"><p>Ev</p>
</td></tr><tr valign="top"><td valign="top"><p>Examiner</p>
</td><td valign="top"><p>Exam</p>
</td></tr><tr valign="top"><td valign="top"><p>FaceSet</p>
</td><td valign="top"><p>FSet</p>
</td></tr><tr valign="top"><td valign="top"><p>Function</p>
</td><td valign="top"><p>Func</p>
</td></tr><tr valign="top"><td valign="top"><p>Highlight</p>
</td><td valign="top"><p>HL</p>
</td></tr><tr valign="top"><td valign="top"><p>Index</p>
</td><td valign="top"><p>Ind (Indexed-&gt;Index)</p>
</td></tr><tr valign="top"><td valign="top"><p>Input</p>
</td><td valign="top"><p>In</p>
</td></tr><tr valign="top"><td valign="top"><p>Integer</p>
</td><td valign="top"><p>Int</p>
</td></tr><tr valign="top"><td valign="top"><p>Keyboard</p>
</td><td valign="top"><p>Key</p>
</td></tr><tr valign="top"><td valign="top"><p>Light</p>
</td><td valign="top"><p>Lgt</p>
</td></tr><tr valign="top"><td valign="top"><p>LineSet</p>
</td><td valign="top"><p>LSet</p>
</td></tr><tr valign="top"><td valign="top"><p>Location</p>
</td><td valign="top"><p>Loc</p>
</td></tr><tr valign="top"><td valign="top"><p>Locator</p>
</td><td valign="top"><p>Loc</p>
</td></tr><tr valign="top"><td valign="top"><p>Manager</p>
</td><td valign="top"><p>Mgr</p>
</td></tr><tr valign="top"><td valign="top"><p>Manipulator</p>
</td><td valign="top"><p>Mnp</p>
</td></tr><tr valign="top"><td valign="top"><p>Material</p>
</td><td valign="top"><p>Mtl</p>
</td></tr><tr valign="top"><td valign="top"><p>Matrix</p>
</td><td valign="top"><p>Mx</p>
</td></tr><tr valign="top"><td valign="top"><p>Normal</p>
</td><td valign="top"><p>Norm</p>
</td></tr><tr valign="top"><td valign="top"><p>Orthographic`</p>
</td><td valign="top"><p>Ortho</p>
</td></tr><tr valign="top"><td valign="top"><p>Output</p>
</td><td valign="top"><p>Out</p>
</td></tr><tr valign="top"><td valign="top"><p>Perspective</p>
</td><td valign="top"><p>Persp</p>
</td></tr><tr valign="top"><td valign="top"><p>Plane</p>
</td><td valign="top"><p>Pln</p>
</td></tr><tr valign="top"><td valign="top"><p>Point</p>
</td><td valign="top"><p>Pt</p>
</td></tr><tr valign="top"><td valign="top"><p>PointSet</p>
</td><td valign="top"><p>PSet</p>
</td></tr><tr valign="top"><td valign="top"><p>Pointer</p>
</td><td valign="top"><p>Ptr</p>
</td></tr><tr valign="top"><td valign="top"><p>Position</p>
</td><td valign="top"><p>Pos</p>
</td></tr><tr valign="top"><td valign="top"><p>Primitive</p>
</td><td valign="top"><p>Prim</p>
</td></tr><tr valign="top"><td valign="top"><p>Profile</p>
</td><td valign="top"><p>Prof</p>
</td></tr><tr valign="top"><td valign="top"><p>Projector</p>
</td><td valign="top"><p>Proj</p>
</td></tr><tr valign="top"><td valign="top"><p>QuadMesh</p>
</td><td valign="top"><p>QMesh</p>
</td></tr><tr valign="top"><td valign="top"><p>RenderArea</p>
</td><td valign="top"><p>RA</p>
</td></tr><tr valign="top"><td valign="top"><p>Rotate</p>
</td><td valign="top"><p>Rot</p>
</td></tr><tr valign="top"><td valign="top"><p>Searching</p>
</td><td valign="top"><p>Search</p>
</td></tr><tr valign="top"><td valign="top"><p>Section</p>
</td><td valign="top"><p>Sect</p>
</td></tr><tr valign="top"><td valign="top"><p>Slider</p>
</td><td valign="top"><p>Sldr</p>
</td></tr><tr valign="top"><td valign="top"><p>String</p>
</td><td valign="top"><p>Str</p>
</td></tr><tr valign="top"><td valign="top"><p>Sphere</p>
</td><td valign="top"><p>Sph</p>
</td></tr><tr valign="top"><td valign="top"><p>Texture</p>
</td><td valign="top"><p>Tex</p>
</td></tr><tr valign="top"><td valign="top"><p>Tolerance</p>
</td><td valign="top"><p>Tol</p>
</td></tr><tr valign="top"><td valign="top"><p>Transform</p>
</td><td valign="top"><p>Xf</p>
</td></tr><tr valign="top"><td valign="top"><p>Translate</p>
</td><td valign="top"><p>Xlate</p>
</td></tr><tr valign="top"><td valign="top"><p>TriangleStripSet</p>
</td><td valign="top"><p>TSet</p>
</td></tr><tr valign="top"><td valign="top"><p>Vec</p>
</td><td valign="top"><p>V(Vec3f-&gt; V3f)</p>
</td></tr><tr valign="top"><td valign="top"><p>Vertex</p>
</td><td valign="top"><p>Vtx</p>
</td></tr><tr valign="top"><td valign="top"><p>Viewer</p>
</td><td valign="top"><p>Vwr</p>
</td></tr><tr valign="top"><td valign="top"><p>Visibility</p>
</td><td valign="top"><p>Vis</p>
</td></tr><tr valign="top"><td valign="top"><p>Wheel</p>
</td><td valign="top"><p>Whl</p>
</td></tr><tr valign="top"><td valign="top"><p>Window</p>
</td><td valign="top"><p>Win</p>
</td></tr></tbody></table></div><br></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5520137"></a><a name="id89901"></a>Creating and Deleting Objects from C</h2></div></div>
<p>The C versions of constructors and destructors are named following a convention slightly different from the one for most member functions. The C constructor for an object of our imaginary type <span class="bold"><b>SoGenericType</b></span> would be <span class="bold"><b>SoGenericTypeCreate()</b></span>. This example shows the C++ and C constructors for the <span class="bold"><b>SoSeparator</b></span> type:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
C++:
</pre></td></tr></table><br><table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SoSeparator *root = new SoSeparator();
C:
SoSep *root;
root = SoSepCreate();
</pre></td></tr></table><p>Destructors are named similarly. A destructor for an object of type <span class="bold"><b>SoGenericType</b></span> would be <span class="bold"><b>SoGenericTypeDelete()</b></span>. To delete a viewer, for example, you might call <span class="bold"><b>SoXtExamVwrDelete(viewer)</b></span>. To delete nodes and groups, you use functions that <i>unreference</i> the node or group, instead of using destructors. See the discussion in <a href="ch03.html#id18184">Chapter 3</a> for details on deleting nodes.</p>
</div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5520278"></a>Overloaded C++ Methods</h2></div></div>
<p>The C++ language allows more than one method of a class to have the same method name, as long as the lists of arguments to the methods are different. This cabability is not provided by the C language, so different function names must be made for each identical method name from C++. Here is an example from the <span class="bold"><b>SoAction</b></span> class:</p>
<p>C++</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
void apply(soNode * node);
void apply(SoPath *path);
</pre></td></tr></table><p>C:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
void SoActApply(SoAction * act, SoNode * node);
void SoActApplyPath(SoAction * act, SoPath * path);
</pre></td></tr></table><br></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5520329"></a><a name="id15842"></a>Calling Functions</h2></div></div>
<p>You should be aware of a few differences between the way C++ calls functions and the way C does. The C++ versions of the Open Inventor methods fill in default values for some arguments. If you omit those arguments, C++ simply calls the function with the defaults. C does not fill in those defaults for you, though. You must supply values for each argument. Here's an example of a C++ call to create an <span class="bold"><b>appWindow</b></span> object, and the equivalent C call:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
C++:
</pre></td></tr></table><br><table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
Widget appWindow = SoXt::init(argv[0]);
C:
widget appWindow;
appwindow = SoXtInit(argv[0], &quot;Inventor&quot;);
</pre></td></tr></table><br></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5520400"></a><a name="id55306"></a>C Classes and Manual Pages</h2></div></div>
<p>There is an online C reference manual page for every Inventor class. For detailed information on a class, see its reference manual page, which lists the functions available to that class and any data structures available. The &#8220;Inherits From&#8221; section tells you which class the current class is derived from. For many classes, this hierarchy can be several layers deep. If you want to know all the functions available to a given class, you need to know the functions available to the parent class. These are listed as part of the synopsis of the manual page. Each class has a separate include file, named after the class.</p>
<p>The reference manual pages also list the suggested default value for function arguments as follows:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
void setSomeValue(x, y, z = 1.0)
</pre></td></tr></table><p>where <span class="bold"><b>z = 1.0</b></span> means that 1.0 is the recommended default value for the argument <i>z</i>.</p>
<p>The reference manual pages use both the abbreviated and the unabbreviated versions of the C class names. Your programs can use both versions as well.</p>
</div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5520483"></a><a name="id26364"></a>A Sample Open Inventor Program in C</h2></div></div>
<p>You now know nearly enough to rewrite Example 2-4 in C. Here's one way you might do so:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
main(int argc, char **argv)
{
   Widget      myWindow;
   SoSep       *root;
   SoMtl       *myMaterial;
   SoCone      *myCone;
   SoXtExamVwr *myViewer;

   myWindow = SoXtInit(argv[0], &quot;Inventor&quot;);
   if (myWindow == NULL) exit(1);

   root = SoSepCreate();
   SoSepRef(root);
   myMaterial = SoMtlCreate();
   myCone     = SoConeCreate();
   SoMColSetR_G_B(&amp;(myMaterial-&gt;diffuseColor), 1.0, 0.0, 0.0);
   SoSepAddChild(root, (SoNode *)myMaterial);
   SoSepAddChild(root, (SoNode *)myCone);

   /* Set up viewer: */
   myViewer = SoXtExamVwrCreateStd(myWindow, NULL);
   SoXtExamVwrSetScene(myViewer, (SoNode *)root);
   SoXtExamVwrSetTitle(myViewer, &quot;Examiner Viewer&quot;);
   SoXtExamVwrShow(myViewer);
   SoXtShow(myWindow);
   SoXtMainLoop();
}
</pre></td></tr></table><br></div></div><!--CONTENT_END--><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="apa.html">Prev</a> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Table of Contents</a></td><td width="40%" align="right"> <a accesskey="n" href="apc.html">Next</a></td></tr><tr><td width="40%" align="left">Appendix A. An Introduction to Object-Oriented Programming for C Programmers </td><td width="20%" align="center"> </td><td width="40%" align="right">Appendix C. Error Handling </td></tr></table></div></body></html>
